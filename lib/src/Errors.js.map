{"version":3,"sources":["../../src/Errors.es6"],"names":["monoline","parts","reduce","str","x","convertStringToJSON","dataString","JSON","parse","_","NUMBER_OF_LEVEL_TO_GO_BACK_ERROR_CLASSIC","NUMBER_OF_LEVEL_TO_GO_BACK_ERROR_HANDLE_STACK_TRACE","codesStorage","Errors","errCode","supString","functionName","getFunctionName","stringError","errorCode","happened","dad","error","setDad","_stringify","serialize","checkErrorOccur","codes","getErrorString","_dad","json","avoid","errorMeaning","getMeaning","moreInfos","happenedAt","console","getColoredErrorString","String","red","bold","isFirst","strsParts","dadsDisplay","push","yellow","blue","grey","finalArrayToDisplay","spacesOffset","underline","forEach","y","toRet","length","ptr","numberFuncToGoBack","err","Error","splitted","stack","split","trimmed","trim","obj","constructError","newErrorObj","conf","DEFAULT_CODES","funcName","handleStackTraceAdd","errToAdd","staticIsAnError","stackTrace","unknown","ESTACKTRACE","E0000","EUNEXPECTED"],"mappings":"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","file":"Errors.js","sourcesContent":["//\n// Copyright (c) 2016 by Cotep. All Rights Reserved.\n//\n\n/*\n * This class handle errors in the app\n */\n\nimport colors from 'colors';\n\n/**\n * Create a monoline from an array which is usefull when you have a line that is too long\n */\nfunction monoline(parts) {\n  return parts.reduce((str, x) => `${str}${x}`, '');\n}\n\n/**\n * Convert a string to JSON\n * If he cannot parse it, return false\n * @param {String} dataString\n */\nfunction convertStringToJSON(dataString) {\n  return (() => {\n    try {\n      return JSON.parse(dataString);\n    } catch (_) {\n      return false;\n    }\n  })();\n}\n\nconst NUMBER_OF_LEVEL_TO_GO_BACK_ERROR_CLASSIC = 3;\n\nconst NUMBER_OF_LEVEL_TO_GO_BACK_ERROR_HANDLE_STACK_TRACE = 3;\n\n/**\n * Holds the errors codes\n */\nlet codesStorage = false;\n\n/**\n * Handles errors in application. It contains Error codes and functions to manage them\n */\nexport default class Errors {\n  /**\n   * @param {String} errCode - the key associated to the error\n   * @param {String} functionName - where the error happened\n   * @param {String} supString - Supplement infos about the error\n   */\n  constructor(errCode, supString, functionName = Errors.getFunctionName(NUMBER_OF_LEVEL_TO_GO_BACK_ERROR_CLASSIC)) {\n    this.stringError = '';\n    this.errorCode = 'E0000';\n    this.happened = '';\n\n    if (errCode) {\n      this.errorCode = errCode;\n\n      if (functionName) this.happened = functionName;\n    }\n\n    if (supString) this.stringError = supString;\n\n    this.dad = false;\n  }\n\n  /**\n   * Return the name of the function that call this function\n   * IT'S A HACK\n   */\n  static getFunctionName(numberFuncToGoBack = 1) {\n    const err = new Error('tmpErr');\n\n    const splitted = err.stack\n      .split('\\n');\n\n    // If we cannot succeed to find the good function name, return the whole data\n    if (numberFuncToGoBack >= splitted.length) {\n      return err.stack;\n    }\n\n    const trimmed = splitted[numberFuncToGoBack]\n      .trim(' ');\n\n    // If we cannot succeed to find the good function name, return the whole data\n    if (!trimmed.length) return err.stack;\n\n    return trimmed.split(' ')[1];\n  }\n\n  /**\n   * We call this function to add some trace to the error\n   * @param {Errors} error - new Error that will help the trace\n   */\n  stackTrace(error) {\n    error.setDad(this);\n\n    return error;\n  }\n\n  /**\n   * Set a dad to the error (used by stack trace to create a stack trace using simple errors)\n   * @param {Errors} error\n   */\n  setDad(error) {\n    this.dad = error;\n  }\n\n  /**\n   * We serialize the error to be able to deserialize it after\n   * @param {?Boolean} _stringify - do we need to stringify before end? Used to call it recurively\n   *\n   * WARNING RECURSIVE FUNCTION\n   */\n  serialize(_stringify = true) {\n    const serialize = {\n      stringError: this.stringError,\n      errorCode: this.errorCode,\n      happened: this.happened,\n      dad: this.dad ? this.dad.serialize(false) : false,\n    };\n\n    return _stringify ? JSON.stringify(serialize) : serialize;\n  }\n\n  /**\n   * We deserialize a previously serialized error\n   * If the string is not a serialized error, create a new error with the string as new error infos\n   * @param {String} str\n   */\n  static deserialize(str) {\n    const obj = convertStringToJSON(str);\n\n    const constructError = (ptr) => {\n      const newErrorObj = new Errors();\n\n      newErrorObj.stringError = ptr.stringError || '';\n      newErrorObj.errorCode = ptr.errorCode || 'EUNEXPECTED';\n      newErrorObj.happened = ptr.happened || '';\n\n      if (ptr.dad) newErrorObj.dad = constructError(ptr.dad);\n\n      return newErrorObj;\n    };\n\n    // If the str is not an Errors serialized data\n    if (!obj) return new Errors('UNKNOWN_ERROR', str);\n\n    return constructError(obj);\n  }\n\n  /**\n   * The default codes of the Error class\n   */\n  static get DEFAULT_CODES() {\n    return {\n      // Special error that say we just want to add some extra stack trace data (but without using new error code)\n      ESTACKTRACE: 'Stack Trace',\n\n      // Default error\n      E0000: 'No Specified Error',\n\n      // Unexpected error\n      EUNEXPECTED: 'Unexpected Error',\n    };\n  }\n\n  /**\n   * Declare codes to the Errors class\n   */\n  static declareCodes(conf) {\n    if (!codesStorage) {\n      codesStorage = Errors.DEFAULT_CODES;\n    }\n\n    codesStorage = {\n      ...codesStorage,\n      ...conf,\n    };\n  }\n\n  /**\n   * Returns the known codes\n   */\n  static get codes() {\n    if (!codesStorage) {\n      codesStorage = Errors.DEFAULT_CODES;\n    }\n\n    return codesStorage;\n  }\n\n  /**\n   * Shortcut to handle an add to stack trace (special add --> ESTACKTRACE type)\n   * @param {String} funcName\n   * @param {?(Errors|Error)} err\n   */\n  static shortcutStackTraceSpecial(err, funcName) {\n    return Errors.handleStackTraceAdd(err, new Errors('ESTACKTRACE', '', funcName), funcName);\n  }\n\n  /**\n   * Add an error into a stack trace, handle the fact of unexpected errors\n   * @param {?(Errors|Error)} err\n   * @param {String} funcName\n   * @param {Errors} errToAdd\n   * @param {Boolean} logIt\n   * @param {?Number} type\n   */\n  static handleStackTraceAdd(err, errToAdd, funcName = Errors.getFunctionName(NUMBER_OF_LEVEL_TO_GO_BACK_ERROR_HANDLE_STACK_TRACE)) {\n    if (!Errors.staticIsAnError(err)) return new Errors('EUNEXPECTED', String(err.stack || err), funcName);\n\n    return err.stackTrace(errToAdd);\n  }\n\n  /**\n   * Check if the errCode is a part of the stackTrace errors\n   * @param {String} errCode\n   */\n  checkErrorOccur(errCode) {\n    if (this.errorCode === errCode) return true;\n\n    if (!this.dad) return false;\n\n    return this.dad.checkErrorOccur(errCode);\n  }\n\n  /**\n   * Get the description associated to the recorded error\n   * @return {string}\n   */\n  getMeaning() {\n    return Errors.codes[this.errorCode] || '';\n  }\n\n  /**\n   * @override\n   */\n  toString() {\n    return this.getErrorString();\n  }\n\n  /**\n   * Get the string that correspond to the recorded error (its a stringified json)\n   * @param {?Boolean} _dad\n   * @return {string}\n   */\n  getErrorString(_dad = false) {\n    const json = {};\n    let avoid = true;\n\n    if (this.errorCode !== 'ESTACKTRACE' || (!_dad && this.errorCode === 'ESTACKTRACE')) {\n      avoid = false;\n      json.errorCode = this.errorCode;\n      json.errorMeaning = this.getMeaning();\n\n      if (this.stringError) json.moreInfos = this.stringError;\n\n      if (this.happened) json.happenedAt = this.happened;\n    }\n\n    if (this.dad) json.dad = this.dad.getErrorString(true);\n\n    if (_dad && avoid) return json.dad;\n\n    if (_dad) return json;\n\n    if (avoid) return JSON.stringify(json.dad);\n\n    return JSON.stringify(json);\n  }\n\n  /**\n   * Display the colored error\n   */\n  displayColoredError() {\n    console.error(this.getColoredErrorString(true));\n  }\n\n  /**\n   * Display the recorded error\n   */\n  displayError() {\n    console.error(String(this.getErrorString())\n      .red.bold);\n  }\n\n  /**\n   * display the error into the console\n   * WARNING THIS FUNCTION IS RECURSIVE\n   * @param {Boolean} isFirst\n   */\n  getColoredErrorString(isFirst = true) {\n    const strsParts = [];\n    let dadsDisplay = [];\n\n    // Get the dad display\n    if (this.dad) {\n      // Here we have something like [dad, dad, dad, dad, dad, dad] displays with the latests the most high level trace\n      dadsDisplay = this.dad.getColoredErrorString(false);\n    }\n\n    // Create our own display\n    if (isFirst || this.errorCode !== 'ESTACKTRACE') {\n      strsParts.push(monoline([\n        '--> Error['.red,\n        `${this.errorCode}`.yellow,\n        ']: ['.red,\n        `${this.getMeaning()}`.yellow,\n        ']\\n'.red,\n      ]));\n    }\n\n    if (this.stringError) strsParts.push(`More infos: [${this.stringError}]\\n`.blue);\n\n    if (this.happened) strsParts.push(`Happened at: [${this.happened}]\\n`.grey);\n\n    // If we are the first called function, it means we have to actually handle the display\n    if (isFirst) {\n      // So have dad to display we have\n      // strsParts which is the highest level trace we have\n      // [dad, dad, dad, dad] which are the others traces, with the last dad the highest level trace\n\n      // Starting with the highest dad we start the display\n      const finalArrayToDisplay = [];\n\n      let spacesOffset = ' ';\n\n      finalArrayToDisplay.push(monoline([\n        'TRACE: '.bold.underline.red,\n        '--------------------------------------------------------------'.bold.red,\n        '\\n',\n      ]));\n\n      strsParts.forEach(x => finalArrayToDisplay.push(`| ${spacesOffset}${x}`));\n\n      dadsDisplay.forEach((x) => {\n        spacesOffset += ' ';\n\n        // When we add it in the final array, we insert the graphical '    ' spaces offset\n        x.forEach(y => finalArrayToDisplay.push(`| ${spacesOffset}${y}`));\n      });\n\n      finalArrayToDisplay.push(monoline([\n        '---------------------------------------------------------------------'.bold.red,\n        '\\n',\n      ]));\n\n      return monoline(finalArrayToDisplay);\n    }\n\n    // We do not have to handle the display just return our display and our dad display\n    let toRet = [];\n\n    if (strsParts.length) toRet.push(strsParts);\n\n    if (dadsDisplay.length) {\n      toRet = [\n        ...toRet,\n        ...dadsDisplay,\n      ];\n    }\n\n    return toRet;\n  }\n\n  /**\n   * Say if the parameter is an instance of the class Error\n   * @param {Object} unknown\n   * @return {Boolean}\n   */\n  static staticIsAnError(unknown) {\n    return unknown instanceof Errors;\n  }\n\n  /**\n   * Set a string to specify more the error\n   * @param {string} error - description of the error\n   */\n  setString(error) {\n    this.stringError = error;\n  }\n\n  /**\n   * Set the error code\n   * @param {String} errCode - key that refer to an error\n   */\n  setErrorCode(errCode) {\n    this.errorCode = errCode;\n  }\n\n  /**\n   * Get the string associated to the last code in stack\n   */\n  getLastStringInStack() {\n    let ptr = this;\n\n    while (ptr.dad) ptr = ptr.dad;\n\n    return ptr.stringError;\n  }\n\n  /**\n   * Get the error code (key that refer to the error)\n   * The last in the stack\n   * @return {String}\n   */\n  getLastErrorCodeInStack() {\n    let ptr = this;\n\n    while (ptr.dad) ptr = ptr.dad;\n\n    return ptr.errorCode;\n  }\n\n  /**\n   * Get the error\n   * The last in the stack\n   * @return {String}\n   */\n  getLastErrorInStack() {\n    let ptr = this;\n\n    while (ptr.dad) ptr = ptr.dad;\n\n    return ptr;\n  }\n\n  /**\n   * Get the error code (key that refer to the error)\n   * @return {String}\n   */\n  getErrorCode() {\n    return this.errorCode;\n  }\n}\n"]}