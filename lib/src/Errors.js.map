{"version":3,"sources":["../../src/Errors.es6"],"names":["monoline","parts","reduce","str","x","convertStringToJSON","dataString","JSON","parse","_","NUMBER_OF_LEVEL_TO_GO_BACK_ERROR_CLASSIC","NUMBER_OF_LEVEL_TO_GO_BACK_ERROR_HANDLE_STACK_TRACE","Errors","errCode","supString","functionName","getFunctionName","stringError","errorCode","happened","dad","error","setDad","_stringify","serialize","checkErrorOccur","Code","getErrorString","_dad","json","avoid","errorMeaning","getMeaning","moreInfos","happenedAt","console","getColoredErrorString","isFirst","strsParts","dadsDisplay","push","red","yellow","blue","grey","finalArrayToDisplay","spacesOffset","bold","underline","forEach","y","toRet","length","unknown","ptr","numberFuncToGoBack","err","Error","splitted","stack","split","trimmed","trim","obj","constructError","newErrorObj","codes","ESTACKTRACE","E0000","EUNEXPECTED","conf","initCodes","funcName","handleStackTraceAdd","errToAdd","staticIsAnError","String","stackTrace"],"mappings":"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","file":"Errors.js","sourcesContent":["//\n// Copyright (c) 2016 by Cotep. All Rights Reserved.\n//\n\n/*\n * This class handle errors in the app\n */\n\nimport colors from 'colors';\n\n/**\n * Create a monoline from an array which is usefull when you have a line that is too long\n */\nfunction monoline(parts) {\n  return parts.reduce((str, x) => `${str}${x}`, '');\n}\n\n/**\n * Convert a string to JSON\n * If he cannot parse it, return false\n * @param {String} dataString\n */\nfunction convertStringToJSON(dataString) {\n  return (() => {\n    try {\n      return JSON.parse(dataString);\n    } catch (_) {\n      return false;\n    }\n  })();\n}\n\nconst NUMBER_OF_LEVEL_TO_GO_BACK_ERROR_CLASSIC = 3;\n\nconst NUMBER_OF_LEVEL_TO_GO_BACK_ERROR_HANDLE_STACK_TRACE = 3;\n\n/**\n * Handles errors in application. It contains Error codes and functions to manage them\n */\nexport default class Errors {\n  /**\n   * @param {String} errCode - the key associated to the error\n   * @param {String} functionName - where the error happened\n   * @param {String} supString - Supplement infos about the error\n   */\n  constructor(errCode, supString, functionName = Errors.getFunctionName(NUMBER_OF_LEVEL_TO_GO_BACK_ERROR_CLASSIC)) {\n    this.stringError = '';\n    this.errorCode = 'E0000';\n    this.happened = '';\n\n    if (errCode) {\n      this.errorCode = errCode;\n\n      if (functionName) this.happened = functionName;\n    }\n\n    if (supString) this.stringError = supString;\n\n    this.dad = false;\n  }\n\n  /**\n   * Return the name of the function that call this function\n   * IT'S A HACK\n   */\n  static getFunctionName(numberFuncToGoBack = 1) {\n    const err = new Error('tmpErr');\n\n    const splitted = err.stack\n      .split('\\n');\n\n    // If we cannot succeed to find the good function name, return the whole data\n    if (numberFuncToGoBack >= splitted.length) {\n      return err.stack;\n    }\n\n    const trimmed = splitted[numberFuncToGoBack]\n      .trim(' ');\n\n    // If we cannot succeed to find the good function name, return the whole data\n    if (!trimmed.length) return err.stack;\n\n    return trimmed.split(' ')[1];\n  }\n\n  /**\n   * We call this function to add some trace to the error\n   * @param {Errors} error - new Error that will help the trace\n   */\n  stackTrace(error) {\n    error.setDad(this);\n\n    return error;\n  }\n\n  /**\n   * Set a dad to the error (used by stack trace to create a stack trace using simple errors)\n   * @param {Errors} error\n   */\n  setDad(error) {\n    this.dad = error;\n  }\n\n  /**\n   * We serialize the error to be able to deserialize it after\n   * @param {?Boolean} _stringify - do we need to stringify before end? Used to call it recurively\n   *\n   * WARNING RECURSIVE FUNCTION\n   */\n  serialize(_stringify = true) {\n    const serialize = {\n      stringError: this.stringError,\n      errorCode: this.errorCode,\n      happened: this.happened,\n      dad: this.dad ? this.dad.serialize(false) : false,\n    };\n\n    return _stringify ? JSON.stringify(serialize) : serialize;\n  }\n\n  /**\n   * We deserialize a previously serialized error\n   * If the string is not a serialized error, create a new error with the string as new error infos\n   * @param {String} str\n   */\n  static deserialize(str) {\n    const obj = convertStringToJSON(str);\n\n    const constructError = (ptr) => {\n      const newErrorObj = new Errors();\n\n      newErrorObj.stringError = ptr.stringError || '';\n      newErrorObj.errorCode = ptr.errorCode || 'EUNEXPECTED';\n      newErrorObj.happened = ptr.happened || '';\n\n      if (ptr.dad) newErrorObj.dad = constructError(ptr.dad);\n\n      return newErrorObj;\n    };\n\n    // If the str is not an Errors serialized data\n    if (!obj) return new Errors('UNKNOWN_ERROR', str);\n\n    return constructError(obj);\n  }\n\n  /**\n   * Initialize the codes\n   */\n  static initCodes() {\n    this.codes = {\n      // Special error that say we just want to add some extra stack trace data (but without using new error code)\n      ESTACKTRACE: 'Stack Trace',\n\n      // Default error\n      E0000: 'No Specified Error',\n\n      // Unexpected error\n      EUNEXPECTED: 'Unexpected Error',\n    };\n  }\n\n  /**\n   * Declare codes to the Errors class\n   */\n  static declareCodes(conf) {\n    if (!this.codes) {\n      Errors.initCodes();\n    }\n\n    this.codes = {\n      ...this.codes,\n      ...conf,\n    };\n  }\n\n  /**\n   * Enum that contains errorCodes\n   * @return {{EX: number}}\n   */\n  static get Code() {\n    if (!this.codes) {\n      Errors.initCodes();\n    }\n\n    return this.codes;\n  }\n\n  /**\n   * Shortcut to handle an add to stack trace (special add --> ESTACKTRACE type)\n   * @param {String} funcName\n   * @param {?(Errors|Error)} err\n   */\n  static shortcutStackTraceSpecial(err, funcName) {\n    return Errors.handleStackTraceAdd(err, new Errors('ESTACKTRACE', '', funcName), funcName);\n  }\n\n  /**\n   * Add an error into a stack trace, handle the fact of unexpected errors\n   * @param {?(Errors|Error)} err\n   * @param {String} funcName\n   * @param {Errors} errToAdd\n   * @param {Boolean} logIt\n   * @param {?Number} type\n   */\n  static handleStackTraceAdd(err, errToAdd, funcName = Errors.getFunctionName(NUMBER_OF_LEVEL_TO_GO_BACK_ERROR_HANDLE_STACK_TRACE)) {\n    if (!Errors.staticIsAnError(err)) return new Errors('EUNEXPECTED', String(err.stack || err), funcName);\n\n    return err.stackTrace(errToAdd);\n  }\n\n  /**\n   * Check if the errCode is a part of the stackTrace errors\n   * @param {String} errCode\n   */\n  checkErrorOccur(errCode) {\n    if (this.errorCode === errCode) return true;\n\n    if (!this.dad) return false;\n\n    return this.dad.checkErrorOccur(errCode);\n  }\n\n  /**\n   * Get the description associated to the recorded error\n   * @return {string}\n   */\n  getMeaning() {\n    return Errors.Code[this.errorCode] || '';\n  }\n\n  /**\n   * @override\n   */\n  toString() {\n    return this.getErrorString();\n  }\n\n  /**\n   * Get the string that correspond to the recorded error (its a stringified json)\n   * @param {?Boolean} _dad\n   * @return {string}\n   */\n  getErrorString(_dad = false) {\n    const json = {};\n    let avoid = true;\n\n    if (this.errorCode !== 'ESTACKTRACE' || (!_dad && this.errorCode === 'ESTACKTRACE')) {\n      avoid = false;\n      json.errorCode = this.errorCode;\n      json.errorMeaning = this.getMeaning();\n\n      if (this.stringError) json.moreInfos = this.stringError;\n\n      if (this.happened) json.happenedAt = this.happened;\n    }\n\n    if (this.dad) json.dad = this.dad.getErrorString(true);\n\n    if (_dad && avoid) return json.dad;\n\n    if (_dad) return json;\n\n    if (avoid) return JSON.stringify(json.dad);\n\n    return JSON.stringify(json);\n  }\n\n  /**\n   * Display the colored error\n   */\n  displayColoredError() {\n    console.error(this.getColoredErrorString(true));\n  }\n\n  /**\n   * display the error into the console\n   * WARNING THIS FUNCTION IS RECURSIVE\n   * @param {Boolean} isFirst\n   */\n  getColoredErrorString(isFirst = true) {\n    const strsParts = [];\n    let dadsDisplay = [];\n\n    // Get the dad display\n    if (this.dad) {\n      // Here we have something like [dad, dad, dad, dad, dad, dad] displays with the latests the most high level trace\n      dadsDisplay = this.dad.getColoredErrorString(false);\n    }\n\n    // Create our own display\n    if (isFirst || this.errorCode !== 'ESTACKTRACE') {\n      strsParts.push(monoline([\n        '--> Error['.red,\n        `${this.errorCode}`.yellow,\n        ']: ['.red,\n        `${this.getMeaning()}`.yellow,\n        ']\\n'.red,\n      ]));\n    }\n\n    if (this.stringError) strsParts.push(`More infos: [${this.stringError}]\\n`.blue);\n\n    if (this.happened) strsParts.push(`Happened at: [${this.happened}]\\n`.grey);\n\n    // If we are the first called function, it means we have to actually handle the display\n    if (isFirst) {\n      // So have dad to display we have\n      // strsParts which is the highest level trace we have\n      // [dad, dad, dad, dad] which are the others traces, with the last dad the highest level trace\n\n      // Starting with the highest dad we start the display\n      const finalArrayToDisplay = [];\n\n      let spacesOffset = ' ';\n\n      finalArrayToDisplay.push(monoline([\n        'TRACE: '.bold.underline.red,\n        '--------------------------------------------------------------'.bold.red,\n        '\\n',\n      ]));\n\n      strsParts.forEach(x => finalArrayToDisplay.push(`| ${spacesOffset}${x}`));\n\n      dadsDisplay.forEach((x) => {\n        spacesOffset += ' ';\n\n        // When we add it in the final array, we insert the graphical '    ' spaces offset\n        x.forEach(y => finalArrayToDisplay.push(`| ${spacesOffset}${y}`));\n      });\n\n      finalArrayToDisplay.push(monoline([\n        '---------------------------------------------------------------------'.bold.red,\n        '\\n',\n      ]));\n\n      return monoline(finalArrayToDisplay);\n    }\n\n    // We do not have to handle the display just return our display and our dad display\n    let toRet = [];\n\n    if (strsParts.length) toRet.push(strsParts);\n\n    if (dadsDisplay.length) {\n      toRet = [\n        ...toRet,\n        ...dadsDisplay,\n      ];\n    }\n\n    return toRet;\n  }\n\n  /**\n   * Display the recorded error\n   */\n  displayError() {\n    console.error(`${this.getErrorString()} - 1`.red.bold);\n  }\n\n  /**\n   * Say if the parameter is an instance of the class Error\n   * @param {Object} unknown\n   * @return {Boolean}\n   */\n  isAnError(unknown) {\n    return unknown instanceof Errors;\n  }\n\n  /**\n   * Say if the parameter is an instance of the class Error\n   * @param {Object} unknown\n   * @return {Boolean}\n   */\n  static staticIsAnError(unknown) {\n    return unknown instanceof Errors;\n  }\n\n  /**\n   * Set a string to specify more the error\n   * @param {string} error - description of the error\n   */\n  setString(error) {\n    this.stringError = error;\n  }\n\n  /**\n   * Set the error code\n   * @param {String} errCode - key that refer to an error\n   */\n  setErrorCode(errCode) {\n    this.errorCode = errCode;\n  }\n\n  /**\n   * Get the string associated to the last code in stack\n   */\n  getLastStringInStack() {\n    let ptr = this;\n\n    while (ptr.dad) ptr = ptr.dad;\n\n    return ptr.stringError;\n  }\n\n  /**\n   * Get the error code (key that refer to the error)\n   * The last in the stack\n   * @return {String}\n   */\n  getLastErrorCodeInStack() {\n    let ptr = this;\n\n    while (ptr.dad) ptr = ptr.dad;\n\n    return ptr.errorCode;\n  }\n\n  /**\n   * Get the error\n   * The last in the stack\n   * @return {String}\n   */\n  getLastErrorInStack() {\n    let ptr = this;\n\n    while (ptr.dad) ptr = ptr.dad;\n\n    return ptr;\n  }\n\n  /**\n   * Get the error code (key that refer to the error)\n   * @return {String}\n   */\n  getErrorCode() {\n    return this.errorCode;\n  }\n}\n"]}