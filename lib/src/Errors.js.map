{"version":3,"sources":["../../src/Errors.ts"],"names":["colors","require","monoline","parts","reduce","str","x","convertStringToJSON","dataString","JSON","parse","_","NUMBER_OF_LEVEL_TO_GO_BACK_ERROR_CLASSIC","NUMBER_OF_LEVEL_TO_GO_BACK_ERROR_HANDLE_STACK_TRACE","codesStorage","Errors","errCode","supString","functionName","getFunctionName","stringError","errorCode","happened","dad","error","setDad","_stringify","serialize","stringify","checkErrorOccur","codes","getErrorString","_dad","json","avoid","errorMeaning","getMeaning","moreInfos","happenedAt","console","getColoredErrorString","bold","red","String","isFirst","strsParts","dadsDisplay","push","yellow","blue","grey","finalArrayToDisplay","spacesOffset","underline","forEach","y","toRet","length","ptr","numberFuncToGoBack","err","Error","splitted","stack","split","trimmed","trim","obj","constructError","newErrorObj","conf","DEFAULT_CODES","funcName","handleStackTraceAdd","errToAdd","staticIsAnError","stackTrace","unknown","ESTACKTRACE","E0000","EUNEXPECTED"],"mappings":"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","sourcesContent":["//\n// Copyright (c) 2016 by Cotep. All Rights Reserved.\n//\n\n/*\n * This class handle errors in the app\n */\n\nconst colors = require('colors/safe');\n\n/**\n * Create a monoline from an array which is usefull when you have a line that is too long\n */\nfunction monoline(parts: any[]): string {\n  return parts.reduce((str: string, x: string) => `${str}${x}`, '');\n}\n\n/**\n * Convert a string to JSON\n * If he cannot parse it, return false\n * @param {String} dataString\n */\nfunction convertStringToJSON(dataString: string): Object | false {\n  return (() => {\n    try {\n      return JSON.parse(dataString);\n    } catch (_) {\n      return false;\n    }\n  })();\n}\n\nconst NUMBER_OF_LEVEL_TO_GO_BACK_ERROR_CLASSIC: number = 3;\n\nconst NUMBER_OF_LEVEL_TO_GO_BACK_ERROR_HANDLE_STACK_TRACE: number = 3;\n\n/**\n * Holds the errors codes\n */\nlet codesStorage: Object | false = false;\n\n/**\n * Handles errors in application. It contains Error codes and functions to manage them\n */\nexport default class Errors {\n  protected stringError: string;\n\n  protected errorCode: string;\n\n  protected happened: string;\n\n  protected dad: Errors | false;\n\n  /**\n   * @param errCode - the key associated to the error\n   * @param functionName - where the error happened\n   * @param supString - Supplement infos about the error\n   */\n  constructor(errCode?: string, supString?: string, functionName: string = Errors.getFunctionName(NUMBER_OF_LEVEL_TO_GO_BACK_ERROR_CLASSIC)) {\n    this.stringError = '';\n    this.errorCode = 'E0000';\n    this.happened = '';\n\n    if (errCode) {\n      this.errorCode = errCode;\n\n      if (functionName) this.happened = functionName;\n    }\n\n    if (supString) this.stringError = supString;\n\n    this.dad = false;\n  }\n\n  /**\n   * Return the name of the function that call this function\n   * IT'S A HACK\n   */\n  static getFunctionName(numberFuncToGoBack: number = 1): string {\n    const err = new Error('tmpErr');\n\n    const splitted = err.stack\n      .split('\\n');\n\n    // If we cannot succeed to find the good function name, return the whole data\n    if (numberFuncToGoBack >= splitted.length) {\n      return err.stack;\n    }\n\n    const trimmed = splitted[numberFuncToGoBack]\n      .trim();\n\n    // If we cannot succeed to find the good function name, return the whole data\n    if (!trimmed.length) return err.stack;\n\n    return trimmed.split(' ')[1];\n  }\n\n  /**\n   * We call this function to add some trace to the error\n   * @param error - new Error that will help the trace\n   */\n  stackTrace(error: Errors): Errors {\n    error.setDad(this);\n\n    return error;\n  }\n\n  /**\n   * Set a dad to the error (used by stack trace to create a stack trace using simple errors)\n   * @param error\n   */\n  setDad(error: Errors): void {\n    this.dad = error;\n  }\n\n  /**\n   * We serialize the error to be able to deserialize it after\n   * @param {?Boolean} _stringify - do we need to stringify before end? Used to call it recurively\n   *\n   * WARNING RECURSIVE FUNCTION\n   */\n  serialize(_stringify: boolean = true): string | Object {\n    const serialize = {\n      stringError: this.stringError,\n      errorCode: this.errorCode,\n      happened: this.happened,\n      dad: this.dad ? this.dad.serialize(false) : false,\n    };\n\n    return _stringify ? JSON.stringify(serialize) : serialize;\n  }\n\n  /**\n   * We deserialize a previously serialized error\n   * If the string is not a serialized error, create a new error with the string as new error infos\n   * @param {String} str\n   */\n  static deserialize(str: string): Object {\n    const obj = convertStringToJSON(str);\n\n    const constructError = (ptr) => {\n      const newErrorObj = new Errors();\n\n      newErrorObj.stringError = ptr.stringError || '';\n      newErrorObj.errorCode = ptr.errorCode || 'EUNEXPECTED';\n      newErrorObj.happened = ptr.happened || '';\n\n      if (ptr.dad) newErrorObj.dad = constructError(ptr.dad);\n\n      return newErrorObj;\n    };\n\n    // If the str is not an Errors serialized data\n    if (!obj) return new Errors('UNKNOWN_ERROR', str);\n\n    return constructError(obj);\n  }\n\n  /**\n   * The default codes of the Error class\n   */\n  static get DEFAULT_CODES(): Object {\n    return {\n      // Special error that say we just want to add some extra stack trace data (but without using new error code)\n      ESTACKTRACE: 'Stack Trace',\n\n      // Default error\n      E0000: 'No Specified Error',\n\n      // Unexpected error\n      EUNEXPECTED: 'Unexpected Error',\n    };\n  }\n\n  /**\n   * Declare codes to the Errors class\n   */\n  static declareCodes(conf: Object): void {\n    if (!codesStorage) {\n      codesStorage = Errors.DEFAULT_CODES;\n    }\n\n    codesStorage = {\n      ...codesStorage,\n      ...conf,\n    };\n  }\n\n  /**\n   * Returns the known codes\n   */\n  static get codes(): Object {\n    if (!codesStorage) {\n      codesStorage = Errors.DEFAULT_CODES;\n    }\n\n    return codesStorage;\n  }\n\n  /**\n   * Shortcut to handle an add to stack trace (special add --> ESTACKTRACE type)\n   */\n  static shortcutStackTraceSpecial(err: Errors | Error, funcName: string): Errors {\n    return Errors.handleStackTraceAdd(err, new Errors('ESTACKTRACE', '', funcName), funcName);\n  }\n\n  /**\n   * Add an error into a stack trace, handle the fact of unexpected errors\n   */\n  static handleStackTraceAdd(err: Errors | Error, errToAdd: Errors, funcName: string = Errors.getFunctionName(NUMBER_OF_LEVEL_TO_GO_BACK_ERROR_HANDLE_STACK_TRACE)) {\n    if (!Errors.staticIsAnError(err)) {\n      return new Errors('EUNEXPECTED', String(err.stack || err), funcName);\n    }\n\n    return err.stackTrace(errToAdd);\n  }\n\n  /**\n   * Check if the errCode is a part of the stackTrace errors\n   */\n  checkErrorOccur(errCode: string): boolean {\n    if (this.errorCode === errCode) return true;\n\n    if (!this.dad) return false;\n\n    return this.dad.checkErrorOccur(errCode);\n  }\n\n  /**\n   * Get the description associated to the recorded error\n   * @return {string}\n   */\n  getMeaning(): string {\n    return Errors.codes[this.errorCode] || '';\n  }\n\n  /**\n   * @override\n   */\n  toString(): string {\n    return this.getErrorString();\n  }\n\n  /**\n   * Get the string that correspond to the recorded error (its a stringified json)\n   * @param {?Boolean} _dad\n   * @return {string}\n   */\n  getErrorString(_dad: boolean = false): string {\n    const json: any = {};\n\n    let avoid = true;\n\n    if (this.errorCode !== 'ESTACKTRACE' || (!_dad && this.errorCode === 'ESTACKTRACE')) {\n      avoid = false;\n      json.errorCode = this.errorCode;\n      json.errorMeaning = this.getMeaning();\n\n      if (this.stringError) json.moreInfos = this.stringError;\n\n      if (this.happened) json.happenedAt = this.happened;\n    }\n\n    if (this.dad) json.dad = this.dad.getErrorString(true);\n\n    if (_dad && avoid) return json.dad;\n\n    if (_dad) return json;\n\n    if (avoid) return JSON.stringify(json.dad);\n\n    return JSON.stringify(json);\n  }\n\n  /**\n   * Display the colored error\n   */\n  displayColoredError(): void {\n    console.error(this.getColoredErrorString(true));\n  }\n\n  /**\n   * Display the recorded error\n   */\n  displayError(): void {\n    console.error(colors.bold(colors.red(String(this.getErrorString()))));\n  }\n\n  /**\n   * display the error into the console\n   * WARNING THIS FUNCTION IS RECURSIVE\n   */\n  getColoredErrorString(isFirst: boolean = true): any {\n    const strsParts = [];\n    let dadsDisplay = [];\n\n    // Get the dad display\n    if (this.dad) {\n      // Here we have something like [dad, dad, dad, dad, dad, dad] displays with the latests the most high level trace\n      dadsDisplay = this.dad.getColoredErrorString(false);\n    }\n\n    // Create our own display\n    if (isFirst || this.errorCode !== 'ESTACKTRACE') {\n      strsParts.push(monoline([\n        '--> Error['.red,\n        `${this.errorCode}`.yellow,\n        ']: ['.red,\n        `${this.getMeaning()}`.yellow,\n        ']\\n'.red,\n      ]));\n    }\n\n    if (this.stringError) strsParts.push(`More infos: [${this.stringError}]\\n`.blue);\n\n    if (this.happened) strsParts.push(`Happened at: [${this.happened}]\\n`.grey);\n\n    // If we are the first called function, it means we have to actually handle the display\n    if (isFirst) {\n      // So have dad to display we have\n      // strsParts which is the highest level trace we have\n      // [dad, dad, dad, dad] which are the others traces, with the last dad the highest level trace\n\n      // Starting with the highest dad we start the display\n      const finalArrayToDisplay = [];\n\n      let spacesOffset = ' ';\n\n      finalArrayToDisplay.push(monoline([\n        colors.red(colors.underline(colors.bold('TRACE: '))),\n        colors.red(colors.bold('--------------------------------------------------------------')),\n        '\\n',\n      ]));\n\n      strsParts.forEach(x => finalArrayToDisplay.push(`| ${spacesOffset}${x}`));\n\n      dadsDisplay.forEach((x) => {\n        spacesOffset += ' ';\n\n        // When we add it in the final array, we insert the graphical '    ' spaces offset\n        x.forEach(y => finalArrayToDisplay.push(`| ${spacesOffset}${y}`));\n      });\n\n      finalArrayToDisplay.push(monoline([\n        colors.bold(colors.red('---------------------------------------------------------------------')),\n        '\\n',\n      ]));\n\n      return monoline(finalArrayToDisplay);\n    }\n\n    // We do not have to handle the display just return our display and our dad display\n    let toRet = [];\n\n    if (strsParts.length) toRet.push(strsParts);\n\n    if (dadsDisplay.length) {\n      toRet = [\n        ...toRet,\n        ...dadsDisplay,\n      ];\n    }\n\n    return toRet;\n  }\n\n  /**\n   * Say if the parameter is an instance of the class Error\n   */\n  static staticIsAnError(unknown: any): unknown is Errors {\n    return unknown instanceof Errors;\n  }\n\n  /**\n   * Set a string to specify more the error\n   */\n  setString(error: string): void {\n    this.stringError = error;\n  }\n\n  /**\n   * Set the error code\n   */\n  setErrorCode(errCode: string): void {\n    this.errorCode = errCode;\n  }\n\n  /**\n   * Get the string associated to the last code in stack\n   */\n  getLastStringInStack(): string {\n    let ptr: Errors = this;\n\n    while (ptr.dad) ptr = ptr.dad;\n\n    return ptr.stringError;\n  }\n\n  /**\n   * Get the error code (key that refer to the error)\n   * The last in the stack\n   * @return {String}\n   */\n  getLastErrorCodeInStack(): string {\n    let ptr: Errors = this;\n\n    while (ptr.dad) ptr = ptr.dad;\n\n    return ptr.errorCode;\n  }\n\n  /**\n   * Get the error\n   * The last in the stack\n   * @return {String}\n   */\n  getLastErrorInStack(): Errors {\n    let ptr: Errors = this;\n\n    while (ptr.dad) ptr = ptr.dad;\n\n    return ptr;\n  }\n\n  /**\n   * Get the error code (key that refer to the error)\n   * @return {String}\n   */\n  getErrorCode(): string {\n    return this.errorCode;\n  }\n}\n"],"file":"Errors.js"}