{"version":3,"sources":["../../src/Errors.es6"],"names":["monoline","parts","reduce","str","x","convertStringToJSON","dataString","JSON","parse","_","NUMBER_OF_LEVEL_TO_GO_BACK_ERROR_CLASSIC","NUMBER_OF_LEVEL_TO_GO_BACK_ERROR_HANDLE_STACK_TRACE","codesStorage","Errors","errCode","supString","functionName","getFunctionName","stringError","errorCode","happened","dad","error","setDad","_stringify","serialize","stringify","checkErrorOccur","codes","getErrorString","_dad","json","avoid","errorMeaning","getMeaning","moreInfos","happenedAt","console","getColoredErrorString","String","red","bold","isFirst","strsParts","dadsDisplay","push","yellow","blue","grey","finalArrayToDisplay","spacesOffset","underline","forEach","y","toRet","length","ptr","numberFuncToGoBack","err","Error","splitted","stack","split","trimmed","trim","obj","constructError","newErrorObj","conf","DEFAULT_CODES","funcName","handleStackTraceAdd","errToAdd","staticIsAnError","stackTrace","unknown","ESTACKTRACE","E0000","EUNEXPECTED"],"mappings":"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","sourcesContent":["//\n// Copyright (c) 2016 by Cotep. All Rights Reserved.\n//\n\n/*\n * This class handle errors in the app\n */\n\nimport colors from 'colors';\n\n/**\n * Create a monoline from an array which is usefull when you have a line that is too long\n */\nfunction monoline(parts) {\n  return parts.reduce((str, x) => `${str}${x}`, '');\n}\n\n/**\n * Convert a string to JSON\n * If he cannot parse it, return false\n * @param {String} dataString\n */\nfunction convertStringToJSON(dataString) {\n  return (() => {\n    try {\n      return JSON.parse(dataString);\n    } catch (_) {\n      return false;\n    }\n  })();\n}\n\nconst NUMBER_OF_LEVEL_TO_GO_BACK_ERROR_CLASSIC = 3;\n\nconst NUMBER_OF_LEVEL_TO_GO_BACK_ERROR_HANDLE_STACK_TRACE = 3;\n\n/**\n * Holds the errors codes\n */\nlet codesStorage = false;\n\n/**\n * Handles errors in application. It contains Error codes and functions to manage them\n */\nexport default class Errors {\n  /**\n   * @param {String} errCode - the key associated to the error\n   * @param {String} functionName - where the error happened\n   * @param {String} supString - Supplement infos about the error\n   */\n  constructor(errCode, supString, functionName = Errors.getFunctionName(NUMBER_OF_LEVEL_TO_GO_BACK_ERROR_CLASSIC)) {\n    this.stringError = '';\n    this.errorCode = 'E0000';\n    this.happened = '';\n\n    if (errCode) {\n      this.errorCode = errCode;\n\n      if (functionName) this.happened = functionName;\n    }\n\n    if (supString) this.stringError = supString;\n\n    this.dad = false;\n  }\n\n  /**\n   * Return the name of the function that call this function\n   * IT'S A HACK\n   */\n  static getFunctionName(numberFuncToGoBack = 1) {\n    const err = new Error('tmpErr');\n\n    const splitted = err.stack\n      .split('\\n');\n\n    // If we cannot succeed to find the good function name, return the whole data\n    if (numberFuncToGoBack >= splitted.length) {\n      return err.stack;\n    }\n\n    const trimmed = splitted[numberFuncToGoBack]\n      .trim(' ');\n\n    // If we cannot succeed to find the good function name, return the whole data\n    if (!trimmed.length) return err.stack;\n\n    return trimmed.split(' ')[1];\n  }\n\n  /**\n   * We call this function to add some trace to the error\n   * @param {Errors} error - new Error that will help the trace\n   */\n  stackTrace(error) {\n    error.setDad(this);\n\n    return error;\n  }\n\n  /**\n   * Set a dad to the error (used by stack trace to create a stack trace using simple errors)\n   * @param {Errors} error\n   */\n  setDad(error) {\n    this.dad = error;\n  }\n\n  /**\n   * We serialize the error to be able to deserialize it after\n   * @param {?Boolean} _stringify - do we need to stringify before end? Used to call it recurively\n   *\n   * WARNING RECURSIVE FUNCTION\n   */\n  serialize(_stringify = true) {\n    const serialize = {\n      stringError: this.stringError,\n      errorCode: this.errorCode,\n      happened: this.happened,\n      dad: this.dad ? this.dad.serialize(false) : false,\n    };\n\n    return _stringify ? JSON.stringify(serialize) : serialize;\n  }\n\n  /**\n   * We deserialize a previously serialized error\n   * If the string is not a serialized error, create a new error with the string as new error infos\n   * @param {String} str\n   */\n  static deserialize(str) {\n    const obj = convertStringToJSON(str);\n\n    const constructError = (ptr) => {\n      const newErrorObj = new Errors();\n\n      newErrorObj.stringError = ptr.stringError || '';\n      newErrorObj.errorCode = ptr.errorCode || 'EUNEXPECTED';\n      newErrorObj.happened = ptr.happened || '';\n\n      if (ptr.dad) newErrorObj.dad = constructError(ptr.dad);\n\n      return newErrorObj;\n    };\n\n    // If the str is not an Errors serialized data\n    if (!obj) return new Errors('UNKNOWN_ERROR', str);\n\n    return constructError(obj);\n  }\n\n  /**\n   * The default codes of the Error class\n   */\n  static get DEFAULT_CODES() {\n    return {\n      // Special error that say we just want to add some extra stack trace data (but without using new error code)\n      ESTACKTRACE: 'Stack Trace',\n\n      // Default error\n      E0000: 'No Specified Error',\n\n      // Unexpected error\n      EUNEXPECTED: 'Unexpected Error',\n    };\n  }\n\n  /**\n   * Declare codes to the Errors class\n   */\n  static declareCodes(conf) {\n    if (!codesStorage) {\n      codesStorage = Errors.DEFAULT_CODES;\n    }\n\n    codesStorage = {\n      ...codesStorage,\n      ...conf,\n    };\n  }\n\n  /**\n   * Returns the known codes\n   */\n  static get codes() {\n    if (!codesStorage) {\n      codesStorage = Errors.DEFAULT_CODES;\n    }\n\n    return codesStorage;\n  }\n\n  /**\n   * Shortcut to handle an add to stack trace (special add --> ESTACKTRACE type)\n   * @param {String} funcName\n   * @param {?(Errors|Error)} err\n   */\n  static shortcutStackTraceSpecial(err, funcName) {\n    return Errors.handleStackTraceAdd(err, new Errors('ESTACKTRACE', '', funcName), funcName);\n  }\n\n  /**\n   * Add an error into a stack trace, handle the fact of unexpected errors\n   * @param {?(Errors|Error)} err\n   * @param {String} funcName\n   * @param {Errors} errToAdd\n   * @param {Boolean} logIt\n   * @param {?Number} type\n   */\n  static handleStackTraceAdd(err, errToAdd, funcName = Errors.getFunctionName(NUMBER_OF_LEVEL_TO_GO_BACK_ERROR_HANDLE_STACK_TRACE)) {\n    if (!Errors.staticIsAnError(err)) return new Errors('EUNEXPECTED', String(err.stack || err), funcName);\n\n    return err.stackTrace(errToAdd);\n  }\n\n  /**\n   * Check if the errCode is a part of the stackTrace errors\n   * @param {String} errCode\n   */\n  checkErrorOccur(errCode) {\n    if (this.errorCode === errCode) return true;\n\n    if (!this.dad) return false;\n\n    return this.dad.checkErrorOccur(errCode);\n  }\n\n  /**\n   * Get the description associated to the recorded error\n   * @return {string}\n   */\n  getMeaning() {\n    return Errors.codes[this.errorCode] || '';\n  }\n\n  /**\n   * @override\n   */\n  toString() {\n    return this.getErrorString();\n  }\n\n  /**\n   * Get the string that correspond to the recorded error (its a stringified json)\n   * @param {?Boolean} _dad\n   * @return {string}\n   */\n  getErrorString(_dad = false) {\n    const json = {};\n    let avoid = true;\n\n    if (this.errorCode !== 'ESTACKTRACE' || (!_dad && this.errorCode === 'ESTACKTRACE')) {\n      avoid = false;\n      json.errorCode = this.errorCode;\n      json.errorMeaning = this.getMeaning();\n\n      if (this.stringError) json.moreInfos = this.stringError;\n\n      if (this.happened) json.happenedAt = this.happened;\n    }\n\n    if (this.dad) json.dad = this.dad.getErrorString(true);\n\n    if (_dad && avoid) return json.dad;\n\n    if (_dad) return json;\n\n    if (avoid) return JSON.stringify(json.dad);\n\n    return JSON.stringify(json);\n  }\n\n  /**\n   * Display the colored error\n   */\n  displayColoredError() {\n    console.error(this.getColoredErrorString(true));\n  }\n\n  /**\n   * Display the recorded error\n   */\n  displayError() {\n    console.error(String(this.getErrorString())\n      .red.bold);\n  }\n\n  /**\n   * display the error into the console\n   * WARNING THIS FUNCTION IS RECURSIVE\n   * @param {Boolean} isFirst\n   */\n  getColoredErrorString(isFirst = true) {\n    const strsParts = [];\n    let dadsDisplay = [];\n\n    // Get the dad display\n    if (this.dad) {\n      // Here we have something like [dad, dad, dad, dad, dad, dad] displays with the latests the most high level trace\n      dadsDisplay = this.dad.getColoredErrorString(false);\n    }\n\n    // Create our own display\n    if (isFirst || this.errorCode !== 'ESTACKTRACE') {\n      strsParts.push(monoline([\n        '--> Error['.red,\n        `${this.errorCode}`.yellow,\n        ']: ['.red,\n        `${this.getMeaning()}`.yellow,\n        ']\\n'.red,\n      ]));\n    }\n\n    if (this.stringError) strsParts.push(`More infos: [${this.stringError}]\\n`.blue);\n\n    if (this.happened) strsParts.push(`Happened at: [${this.happened}]\\n`.grey);\n\n    // If we are the first called function, it means we have to actually handle the display\n    if (isFirst) {\n      // So have dad to display we have\n      // strsParts which is the highest level trace we have\n      // [dad, dad, dad, dad] which are the others traces, with the last dad the highest level trace\n\n      // Starting with the highest dad we start the display\n      const finalArrayToDisplay = [];\n\n      let spacesOffset = ' ';\n\n      finalArrayToDisplay.push(monoline([\n        'TRACE: '.bold.underline.red,\n        '--------------------------------------------------------------'.bold.red,\n        '\\n',\n      ]));\n\n      strsParts.forEach(x => finalArrayToDisplay.push(`| ${spacesOffset}${x}`));\n\n      dadsDisplay.forEach((x) => {\n        spacesOffset += ' ';\n\n        // When we add it in the final array, we insert the graphical '    ' spaces offset\n        x.forEach(y => finalArrayToDisplay.push(`| ${spacesOffset}${y}`));\n      });\n\n      finalArrayToDisplay.push(monoline([\n        '---------------------------------------------------------------------'.bold.red,\n        '\\n',\n      ]));\n\n      return monoline(finalArrayToDisplay);\n    }\n\n    // We do not have to handle the display just return our display and our dad display\n    let toRet = [];\n\n    if (strsParts.length) toRet.push(strsParts);\n\n    if (dadsDisplay.length) {\n      toRet = [\n        ...toRet,\n        ...dadsDisplay,\n      ];\n    }\n\n    return toRet;\n  }\n\n  /**\n   * Say if the parameter is an instance of the class Error\n   * @param {Object} unknown\n   * @return {Boolean}\n   */\n  static staticIsAnError(unknown) {\n    return unknown instanceof Errors;\n  }\n\n  /**\n   * Set a string to specify more the error\n   * @param {string} error - description of the error\n   */\n  setString(error) {\n    this.stringError = error;\n  }\n\n  /**\n   * Set the error code\n   * @param {String} errCode - key that refer to an error\n   */\n  setErrorCode(errCode) {\n    this.errorCode = errCode;\n  }\n\n  /**\n   * Get the string associated to the last code in stack\n   */\n  getLastStringInStack() {\n    let ptr = this;\n\n    while (ptr.dad) ptr = ptr.dad;\n\n    return ptr.stringError;\n  }\n\n  /**\n   * Get the error code (key that refer to the error)\n   * The last in the stack\n   * @return {String}\n   */\n  getLastErrorCodeInStack() {\n    let ptr = this;\n\n    while (ptr.dad) ptr = ptr.dad;\n\n    return ptr.errorCode;\n  }\n\n  /**\n   * Get the error\n   * The last in the stack\n   * @return {String}\n   */\n  getLastErrorInStack() {\n    let ptr = this;\n\n    while (ptr.dad) ptr = ptr.dad;\n\n    return ptr;\n  }\n\n  /**\n   * Get the error code (key that refer to the error)\n   * @return {String}\n   */\n  getErrorCode() {\n    return this.errorCode;\n  }\n}\n"],"file":"Errors.js"}