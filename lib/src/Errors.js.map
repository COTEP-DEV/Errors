{"version":3,"sources":["../../src/Errors.es6"],"names":["getFunctionName","numberFuncToGoBack","err","Error","splitted","stack","split","length","trimmed","trim","NUMBER_OF_LEVEL_TO_GO_BACK_ERROR_CLASSIC","Errors","errCode","supString","functionName","stringError","errorCode","happened","dad","error","setDad","_stringify","serialize","checkErrorOccur","Code","getErrorString","_dad","json","avoid","errorMeaning","getMeaning","moreInfos","happenedAt","console","getColoredErrorString","isFirst","strsParts","dadsDisplay","push","Utils","monoline","red","yellow","blue","grey","finalArrayToDisplay","spacesOffset","bold","underline","forEach","x","y","toRet","unknown","ptr","str","obj","convertStringToJSON","constructError","newErrorObj","funcName","handleStackTraceAdd","errToAdd","NUMBER_OF_LEVEL_TO_GO_BACK_ERROR_HANDLE_STACK_TRACE","staticIsAnError","String","stackTrace","ESTACKTRACE","E0000","EUNEXPECTED"],"mappings":"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","file":"Errors.js","sourcesContent":["//\n// Copyright (c) 2016 by Cotep. All Rights Reserved.\n//\n\n/*\n * This class handle errors in the app\n */\n\nimport colors from 'colors';\n\n/**\n * Return the name of the function that call this function\n * IT'S A HACK\n */\nfunction getFunctionName(numberFuncToGoBack = 1) {\n  const err = new Error('tmpErr');\n\n  const splitted = err.stack\n    .split('\\n');\n\n  // If we cannot succeed to find the good function name, return the whole data\n  if (numberFuncToGoBack >= splitted.length) {\n    return err.stack;\n  }\n\n  const trimmed = splitted[numberFuncToGoBack]\n    .trim(' ');\n\n  // If we cannot succeed to find the good function name, return the whole data\n  if (!trimmed.length) return err.stack;\n\n  return trimmed.split(' ')[1];\n}\n\nconst NUMBER_OF_LEVEL_TO_GO_BACK_ERROR_CLASSIC = 3;\n\n/**\n * Handles errors in application. It contains Error codes and functions to manage them\n */\nexport default class Errors {\n  /**\n   * @param {String} errCode - the key associated to the error\n   * @param {String} functionName - where the error happened\n   * @param {String} supString - Supplement infos about the error\n   */\n  constructor(errCode, supString, functionName = getFunctionName(NUMBER_OF_LEVEL_TO_GO_BACK_ERROR_CLASSIC)) {\n    this.stringError = '';\n    this.errorCode = 'E0000';\n    this.happened = '';\n\n    if (errCode) {\n      this.errorCode = errCode;\n\n      if (functionName) this.happened = functionName;\n    }\n\n    if (supString) this.stringError = supString;\n\n    this.dad = false;\n  }\n\n  /**\n   * We call this function to add some trace to the error\n   * @param {Errors} error - new Error that will help the trace\n   */\n  stackTrace(error) {\n    error.setDad(this);\n\n    return error;\n  }\n\n  /**\n   * Set a dad to the error (used by stack trace to create a stack trace using simple errors)\n   * @param {Errors} error\n   */\n  setDad(error) {\n    this.dad = error;\n  }\n\n  /**\n   * We serialize the error to be able to deserialize it after\n   * @param {?Boolean} _stringify - do we need to stringify before end? Used to call it recurively\n   *\n   * WARNING RECURSIVE FUNCTION\n   */\n  serialize(_stringify = true) {\n    const serialize = {\n      stringError: this.stringError,\n      errorCode: this.errorCode,\n      happened: this.happened,\n      dad: this.dad ? this.dad.serialize(false) : false,\n    };\n\n    return _stringify ? JSON.stringify(serialize) : serialize;\n  }\n\n  /**\n   * We deserialize a previously serialized error\n   * If the string is not a serialized error, create a new error with the string as new error infos\n   * @param {String} str\n   */\n  static deserialize(str) {\n    const obj = Utils.convertStringToJSON(str);\n\n    const constructError = (ptr) => {\n      const newErrorObj = new Errors();\n\n      newErrorObj.stringError = ptr.stringError || '';\n      newErrorObj.errorCode = ptr.errorCode || 'EUNEXPECTED';\n      newErrorObj.happened = ptr.happened || '';\n\n      if (ptr.dad) newErrorObj.dad = constructError(ptr.dad);\n\n      return newErrorObj;\n    };\n\n    // If the str is not an Errors serialized data\n    if (!obj) return new Errors('UNKNOWN_ERROR', str);\n\n    return constructError(obj);\n  }\n\n  /**\n   * Enum that contains errorCodes\n   * @return {{EX: number}}\n   */\n  static get Code() {\n    return {\n      // Special error that say we just want to add some extra stack trace data (but without using new error code)\n      ESTACKTRACE: 'Stack Trace',\n\n      // Default error\n      E0000: 'No Specified Error',\n\n      // Unexpected error\n      EUNEXPECTED: 'Unexpected Error',\n    };\n  }\n\n  /**\n   * Shortcut to handle an add to stack trace (special add --> ESTACKTRACE type)\n   * @param {String} funcName\n   * @param {?(Errors|Error)} err\n   */\n  static shortcutStackTraceSpecial(err, funcName) {\n    return Errors.handleStackTraceAdd(err, new Errors('ESTACKTRACE', '', funcName), funcName);\n  }\n\n  /**\n   * Add an error into a stack trace, handle the fact of unexpected errors\n   * @param {?(Errors|Error)} err\n   * @param {String} funcName\n   * @param {Errors} errToAdd\n   * @param {Boolean} logIt\n   * @param {?Number} type\n   */\n  static handleStackTraceAdd(err, errToAdd, funcName = getFunctionName(NUMBER_OF_LEVEL_TO_GO_BACK_ERROR_HANDLE_STACK_TRACE)) {\n    if (!Errors.staticIsAnError(err)) return new Errors('EUNEXPECTED', String(err.stack || err), funcName);\n\n    return err.stackTrace(errToAdd);\n  }\n\n  /**\n   * Check if the errCode is a part of the stackTrace errors\n   * @param {String} errCode\n   */\n  checkErrorOccur(errCode) {\n    if (this.errorCode === errCode) return true;\n\n    if (!this.dad) return false;\n\n    return this.dad.checkErrorOccur(errCode);\n  }\n\n  /**\n   * Get the description associated to the recorded error\n   * @return {string}\n   */\n  getMeaning() {\n    return Errors.Code[this.errorCode] || '';\n  }\n\n  /**\n   * @override\n   */\n  toString() {\n    return this.getErrorString();\n  }\n\n  /**\n   * Get the string that correspond to the recorded error (its a stringified json)\n   * @param {?Boolean} _dad\n   * @return {string}\n   */\n  getErrorString(_dad = false) {\n    const json = {};\n    let avoid = true;\n\n    if (this.errorCode !== 'ESTACKTRACE' || (!_dad && this.errorCode === 'ESTACKTRACE')) {\n      avoid = false;\n      json.errorCode = this.errorCode;\n      json.errorMeaning = this.getMeaning();\n\n      if (this.stringError) json.moreInfos = this.stringError;\n\n      if (this.happened) json.happenedAt = this.happened;\n    }\n\n    if (this.dad) json.dad = this.dad.getErrorString(true);\n\n    if (_dad && avoid) return json.dad;\n\n    if (_dad) return json;\n\n    if (avoid) return JSON.stringify(json.dad);\n\n    return JSON.stringify(json);\n  }\n\n  /**\n   * Display the colored error\n   */\n  displayColoredError() {\n    console.error(this.getColoredErrorString(true));\n  }\n\n  /**\n   * display the error into the console\n   * WARNING THIS FUNCTION IS RECURSIVE\n   * @param {Boolean} isFirst\n   */\n  getColoredErrorString(isFirst = true) {\n    const strsParts = [];\n    let dadsDisplay = [];\n\n    // Get the dad display\n    if (this.dad) {\n      // Here we have something like [dad, dad, dad, dad, dad, dad] displays with the latests the most high level trace\n      dadsDisplay = this.dad.getColoredErrorString(false);\n    }\n\n    // Create our own display\n    if (isFirst || this.errorCode !== 'ESTACKTRACE') {\n      strsParts.push(Utils.monoline([\n        '--> Error['.red,\n        `${this.errorCode}`.yellow,\n        ']: ['.red,\n        `${this.getMeaning()}`.yellow,\n        ']\\n'.red,\n      ]));\n    }\n\n    if (this.stringError) strsParts.push(`More infos: [${this.stringError}]\\n`.blue);\n\n    if (this.happened) strsParts.push(`Happened at: [${this.happened}]\\n`.grey);\n\n    // If we are the first called function, it means we have to actually handle the display\n    if (isFirst) {\n      // So have dad to display we have\n      // strsParts which is the highest level trace we have\n      // [dad, dad, dad, dad] which are the others traces, with the last dad the highest level trace\n\n      // Starting with the highest dad we start the display\n      const finalArrayToDisplay = [];\n\n      let spacesOffset = ' ';\n\n      finalArrayToDisplay.push(Utils.monoline([\n        'TRACE: '.bold.underline.red,\n        '--------------------------------------------------------------'.bold.red,\n        '\\n',\n      ]));\n\n      strsParts.forEach(x => finalArrayToDisplay.push(`| ${spacesOffset}${x}`));\n\n      dadsDisplay.forEach((x) => {\n        spacesOffset += ' ';\n\n        // When we add it in the final array, we insert the graphical '    ' spaces offset\n        x.forEach(y => finalArrayToDisplay.push(`| ${spacesOffset}${y}`));\n      });\n\n      finalArrayToDisplay.push(Utils.monoline([\n        '---------------------------------------------------------------------'.bold.red,\n        '\\n',\n      ]));\n\n      return Utils.monoline(finalArrayToDisplay);\n    }\n\n    // We do not have to handle the display just return our display and our dad display\n    let toRet = [];\n\n    if (strsParts.length) toRet.push(strsParts);\n\n    if (dadsDisplay.length) {\n      toRet = [\n        ...toRet,\n        ...dadsDisplay,\n      ];\n    }\n\n    return toRet;\n  }\n\n  /**\n   * Display the recorded error\n   */\n  displayError() {\n    console.error(`${this.getErrorString()} - 1`.red.bold);\n  }\n\n  /**\n   * Say if the parameter is an instance of the class Error\n   * @param {Object} unknown\n   * @return {Boolean}\n   */\n  isAnError(unknown) {\n    return unknown instanceof Errors;\n  }\n\n  /**\n   * Say if the parameter is an instance of the class Error\n   * @param {Object} unknown\n   * @return {Boolean}\n   */\n  static staticIsAnError(unknown) {\n    return unknown instanceof Errors;\n  }\n\n  /**\n   * Set a string to specify more the error\n   * @param {string} error - description of the error\n   */\n  setString(error) {\n    this.stringError = error;\n  }\n\n  /**\n   * Set the error code\n   * @param {String} errCode - key that refer to an error\n   */\n  setErrorCode(errCode) {\n    this.errorCode = errCode;\n  }\n\n  /**\n   * Get the string associated to the last code in stack\n   */\n  getLastStringInStack() {\n    let ptr = this;\n\n    while (ptr.dad) ptr = ptr.dad;\n\n    return ptr.stringError;\n  }\n\n  /**\n   * Get the error code (key that refer to the error)\n   * The last in the stack\n   * @return {String}\n   */\n  getLastErrorCodeInStack() {\n    let ptr = this;\n\n    while (ptr.dad) ptr = ptr.dad;\n\n    return ptr.errorCode;\n  }\n\n  /**\n   * Get the error\n   * The last in the stack\n   * @return {String}\n   */\n  getLastErrorInStack() {\n    let ptr = this;\n\n    while (ptr.dad) ptr = ptr.dad;\n\n    return ptr;\n  }\n\n  /**\n   * Get the error code (key that refer to the error)\n   * @return {String}\n   */\n  getErrorCode() {\n    return this.errorCode;\n  }\n}\n"]}